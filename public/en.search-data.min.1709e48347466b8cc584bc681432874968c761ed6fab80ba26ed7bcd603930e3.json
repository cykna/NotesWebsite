[{"id":0,"href":"/notes/algorithms/big-o-notation/","title":"Big O Notation","section":"Notes","content":"Big O Notation is the way people use to talk about the growing of some algorithm. This can be used on performance, memory usage and others, even though talking about these we require more than simply Big O. When working with Big O, we will work actually with a rule that can be applied to a code to measure it, but it doesn\u0026rsquo;t mean that code will always be run slowly or fast. Actually, an optimized code can run slowly if the machine running it isn\u0026rsquo;t fast enough, while, a non-optimized code can run it with not so much problems if the machine running it is fast enough for so. In reality what big o will do estimate how much a code will need to finish based on an input I, or grow in terms of memory. Here it\u0026rsquo;s being talked mainly about the amount of instructions to finish some algorithm. For measuring so we use the \u0026lsquo;O\u0026rsquo; notation. To things don\u0026rsquo;t keep too theoretical, let\u0026rsquo;s suppose the following code:\n///Creates a new Vector with each value following the rule: I * Position, where L is the value provided on the `input` vector and Position it\u0026#39;s index on it fn double_vector(vec: Vec\u0026lt;f32\u0026gt;) -\u0026gt; Vec\u0026lt;f32\u0026gt; { vec.iter().enumerate().map(|(index,value)| value * index as f32) }Let\u0026rsquo;s say we executed double_vector(vec![5.0f32, 10.0, 20.0, 15.0, 12.0, 17.0]). What\u0026rsquo;s going to happen is that the code will have to iterate over this [[Vector|vector]] and produce a new one based on it. On this example, then, the function inside the map will be executed 6 times, but, lets suppose we create a new vector with 1000 elements. Something like double_vector(random_vector(1000)) will then execute 1000 times. Now we can find a pattern! That is: the code will run the L times to finish, where L is the length of elements of the input vector, thus, we can say that the code is O(L) because, based on L, L operations happen. Let\u0026rsquo;s suppose now the following:\nfn arbitrary_calc(vec: Vec\u0026lt;u32\u0026gt;) -\u0026gt; Vec\u0026lt;u32\u0026gt; { let mut out = Vec::new(); for val in vec { let mut n = val * 3; n += 5; out.push(n); } }Here we execute an allocation, a multiplication, a sum, and a pushing, then we are executing about O(n * 4) instructions, where nis the amount of elements in vec. The thing is that on getting bigger and bigger, what will take more effect on the amount of instructions required to finish is n, then, we can say the function is still O(n)\nO(N²) # When something is understood as O(n²), that means that the way a given function f increases based on the given input is squared, for example:\nfn has_pair_with_sum(nums: \u0026amp;[i32], target: i32) -\u0026gt; bool { for i in 0..nums.len() { for j in (i + 1)..nums.len() { if nums[i] + nums[j] == target { return true; } } } false }Supposing we called this function as has_pair_with_sum(\u0026amp;[10, 20, 4, 13, 7], 20), and supposing the worst case where we got to iterate over all the slice, we will have that:\nThe code starts running from 0..5 given by the 0..nums.len(), then, we will run from 1..5 and check, so we will have 4 instructions made. On the next we will do 1..5 and 2..5, which will be more 3 On the next we will do 2..5 and 3..5 which will be more 2 On the next we will do 3..5 and 4..5 which will be more 1 On the next, no more is made So in the total we will have about 10 instructions made. Well, the pattern understood is that based on a given [[Slice|slice]] with N elements, we will have about $$\\sum_{k=1}^N k$$ So, on a input of 6 elements, we will have 15 instructions, on 7 instructions, 21, later 28, and so on. The given summary formula can be then rewrote as the following: $$S = 1 + 2 + 3 .. + N$$ which, when we invert so, it can be rewritten as the following: $$S = N + (N-1) + (N-2) + (N-3) .. + 2 + 1$$ where S = the total amount of instructions needed to execute on the worst case. Actually on summing both sides, we will have the following formula $$S = 1 + 2 + 3 .. + N$$ $$S = N + (N-1)+(N-2) .. + 1$$ $$ S + S = (N+1) + ((N-1)+2) + ((N-2) + 3) .. + ((N + 1)$$ Which can be simplified to: $$2S = (N+1)+(N+1)+(N+1)+(N+1)..+(N+1)$$ Where the amount of the [[BinaryExpression|right hand side]] of sums of (N+1) is N, so, we can rewrite it another way like: $$2S = N(N+1)$$ $$S = N(N+1)/2$$ $$S = (N²+N)/2$$ which contains a N². So, as the amount of inputs increase, this is the order of how much the function will increase. Actually it\u0026rsquo;s O(N(N+1)/2), but as N² is the thing that will start to take more effect on the total amount of instructions needed to finish, we can ignore the others and then write it as simple as O(N²) The same logic follows Big O all around when we talk about O(log n) O(n log n) O(n!)and others.\nNot Necessarily Good # When using [[LinkedList|linked lists]] for example, we find that it\u0026rsquo;s O(1) for insertion, but not necessarily it\u0026rsquo;s a good thing. For insertion on the middle of the list, if not knowing the correct node, it\u0026rsquo;s O(n), because we might traverse all the list to then find the one we want to insert something at. Another problem is that as linked lists are not a contiguous memory block, which then makes it not [[CpuCaching|cache friendly]], which can degrade performance depending on the amount of elements on the list. Depending on the amount of the data, as linked lists use pointers to define the next node, this can cause overhead, which for example, arrays do not have. That doesn\u0026rsquo;t mean that Big O is \u0026lsquo;wrong\u0026rsquo; but we need to actually consider other things than only it when talking about memory usage and performance. It can, and is used as a parameter but lacks of completeness to determine is some is actually good or not. When talking about performance, in general, it\u0026rsquo;s just going to say how many instructions are required to some algorithm finalize\n"},{"id":1,"href":"/notes/algorithms/recursion/","title":"Recursion","section":"Notes","content":"Recursion is occurs when a something uses itself on its definition, for example, with mathematical functions: $f(x) = 1 + f(x-1)$ This function f, on it\u0026rsquo;s definition, calls itself, then, it\u0026rsquo;s considered a recursive function. That can be written in it\u0026rsquo;s code format with the following:\nfn f(n:i32) -\u0026gt; i32{ 1 + f(n-1) }But recursion can appear in other situations than simply function calls, for example, let\u0026rsquo;s say the following rule: $$0 \\in N$$ $$\\forall n \\in N, n+1 \\in N$$ Then, this rule is recursive as well, because it uses itself to determine that $n \\in N$ . Going back to programming, one kind of data structure that is recursive are [[LinkedList|linked lists]] and [[Trees|trees]], for example:\nstruct LinkedList\u0026lt;T\u0026gt; { next: LinkedList, value: T }This struct has as some of its fields, itself, being obligatory to it exists. That leads us to that, when creating, we need to create an infinite amount of linked lists, which would require as well, infinite ram. So, one of the problems of recursion in general is that we MUST have some way to determine where to end, because if not, the task won\u0026rsquo;t finish. That condition is called Base case, which is some scenario that will not use recursion to produce some value, then, when reached, will stop the execution. It can be understood with the way we define $N!$, it can be defined as $$N! = \\begin{cases}{1, \\text{ if } N = 0 \\[4pt] N \\cdot (N-1)!, \\text{ if } N \u0026gt; 0}\\end{cases}$$ Then we can write this function with rust the following way:\nfn fac(n:u32) -\u0026gt; u32 { if n ==0 { 1 }else { n * fac(n-1) } }For the linked list struct, a solution is that, a Node that doesn\u0026rsquo;t point to another Node, so, the structure would be\nstruct LinkedList\u0026lt;T\u0026gt; { next: Option\u0026lt;Box\u0026lt;LinkedList\u0026gt;\u0026gt;, value: T }The reason why a [[Pointer]] is used it\u0026rsquo;s because its size on the memory is usize, so when compiling the code, the compiler knows how many [[Bytes]] to allocate. If not, we would end up with the same recursion problem of infinite memory being required.\nUsages # When working with recursive data structures, we can do use recursion as a way to iterating over it, but depending on the way it\u0026rsquo;s executed, it might not be as fast as some non-recursive formula and or iterations. The thing is that due to it\u0026rsquo;s nature, recursion is almost never [[Big O Notation|O(1)]], so, for example, Fibonnaci, it can be written in rust with the following:\npub fn fib_naive(n: u64) -\u0026gt; u64 { match n { 0 =\u0026gt; 0, 1 =\u0026gt; 1, _ =\u0026gt; fib_naive(n - 1) + fib_naive(n - 2), } }``` Which will lead us to an \u0026#34;exponential\u0026#34; growth. When we run the following code: ```rust pub fn fib_naive(n: u64, inc: \u0026amp;mut usize) -\u0026gt; u64 { *inc += 1; match n { 0 =\u0026gt; 0, 1 =\u0026gt; 1, _ =\u0026gt; fib_naive(n - 1, inc) + fib_naive(n - 2, inc), } } fn main() { let mut index = 0; fib_naive(20, \u0026amp;mut index); println!(\u0026#34;Fib naive executed {index} times\u0026#34;); }we have that, on finalizing, we will have the following output:\ncargo run Compiling fib v0.1.0 (~/programming/notes/fib) Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.29s Running `target/debug/fib` Fib naive executed 21891 timeswhich is terrible(obs: both on optimized and unoptimized versions of the code, rust still executes the same amount of 21891 function calls). Since each function call generates a new [[StackFrame|stack frame]], we are creating about 22.000 stack frames, which then can lead us to some [[StackOverflow|stack overflow]] error. So, we can have some ways to make it better, one of the ways is by [[Memoization|memoizing]] the data to don\u0026rsquo;t call it over and over again to recompute the same values, but, let\u0026rsquo;s focus on the most performant options, which would be O(1). If we look up on some equivalents for the Fibonnaci series, we find the following formula which uses Golden Ratio to calculate it: $$L(N) = (\\frac{(1+\\sqrt5}2)^N + (\\frac{1-\\sqrt5}2)^N $$ Which can be written in rust as:\nfn fib(n:u64) -\u0026gt; u64 { const RATIO = (1.0 + (5.0).sqrt()) * 0.5; const NEG_RATIO = (1.0 - (5.0).sqrt()) * 0.5; let n = n as f64; (RATIO.powf(n) + NEG_RATIO.powf(n)) as u64 }Now, we specify a constant amount of instructions to do, which does categorize this implementation as O(1). Note that the const values are created once during compile time. Todo: More examples of recursion, such as trees\n"},{"id":2,"href":"/notes/algorithms/treetraversal/posorder/","title":"Pos Order","section":"Notes","content":"PosOrder is practically the opposite of [[PreOrder]] when working with trees. [[PreOrder]] defines that something will happen with the children first, then, it will happen with the parent. PosOrder is the opposite, it happens with the parent first, and then the children. One example is an [[UI]] that is defined as a Tree, which isn\u0026rsquo;t unusual. When rendering so, we cannot render the children before the parents, which would be categorized as PreOrder, instead, we MUST, draw first the parents and going deeper on the children, then, the children will appear on top of the parents. This can be reached by the following code:\n///Renders the given `element` using the `painter` and it\u0026#39;s children. `set` is used to get track of which ///elements were already drawn, and `key` is the key of the `element` is going to be drawed fn render_element( \u0026amp;self, painter: \u0026amp;mut P, element: \u0026amp;CandyNode\u0026lt;P\u0026gt;, set: \u0026amp;mut HashSet\u0026lt;CandyKey\u0026gt;, key: \u0026amp;CandyKey, ) { if set.contains(key) { return; } set.insert(*key); element.render(painter); for child_key in element.children() { if let Some(child) = self.elements.get(*child_key) { self.render_element(painter, child, set, child_key); } } } ///Render all the tree using the given `painter` pub fn render(\u0026amp;self, painter: \u0026amp;mut P) { let mut set = HashSet::new(); for (key, el) in self.elements.iter() { if set.contains(\u0026amp;key) { continue; } self.render_element(painter, el, \u0026amp;mut set, \u0026amp;key); } }``` Note that all the logic is made first on the current `element` and then on the element `children` which calls the same function [[Recursion|recursively]]"},{"id":3,"href":"/notes/algorithms/treetraversal/preorder/","title":"Pre Order","section":"Notes","content":"When working with trees, at some times we want to traverse it and work with the children before the parent, that method is called \u0026lsquo;PreOrder\u0026rsquo;. For example, on making my UI library, I had to write a way to know which element I was clicking at, for so, it was required the usage of PreOrder. Since the children are drawn after the parent, they\u0026rsquo;re \u0026lsquo;closer\u0026rsquo; to the screen, so it makes sense for them to be checked, then, i should check for it\u0026rsquo;s parent after checking for them, which then, configures as a PreOrder traverse. This can be understood better at the [[GenericTree]]. Supposing we traverse that tree using [[PosOrder]], and we print the numbers, the result would be something like 1,2,3,4,5,6,7,8,9,10, thus, we are looking for the parent then for the children, but with our case its quite the opposite, in case we wanted 10,9,8,7,6,5,4,3,2,1which will look for the children first. Leaving the theory, a practical code using [[Recursion]] I made is the following:\n///Tests if the `position` is inside the bounds of some child of `element` if not, check for `element` ///This function is recursive and used to follow z-index rules. ///Returns the Key of the deepest element that reaches so, if none matches, returns None pub fn find_deepest_at( \u0026amp;self, element_key: CandyKey, element: \u0026amp;CandyNode\u0026lt;P\u0026gt;, position: Vector2\u0026lt;f32\u0026gt;, ) -\u0026gt; Option\u0026lt;CandyKey\u0026gt; { for child in element.children() { if let Some(_) = self.test_hit(*child, self.elements.get(*child).unwrap(), position) { return Some(*child); }; } let mut bounds = element.bounds(); if let CandyElement::Text(_) = \u0026amp;element.inner { bounds.y -= bounds.w; } if in_bounds_of(bounds, position) { Some(element_key) } else { None } }Where the function looks first for the children and then, if none return, we check for the element itself. Even though the code looks to be [[Big O Notation|O(N²)]], it is instead O(N) because it executes on every children of the given element exactly once The source code of the given function can be found [[https://github.com/cykna/candy/blob/uitree/src/ui/tree/tree.rs|here]]\n"},{"id":4,"href":"/notes/basis/bytes/","title":"Bytes","section":"Notes","content":"When starting to work with computers, we must understand how data is structured. The way data is structured is called bytes. It\u0026rsquo;s a sequence of 8 bits. Where a bit is actually named as \u0026lsquo;binary digit\u0026rsquo;. The value of a bit is either 0 or 1, on the physics, it\u0026rsquo;s when a transistor is \u0026lsquo;activated\u0026rsquo;, if so, it\u0026rsquo;s 1, if not is 0. The group of 8 bits is called a byte. In programming, in reality everything is an abstraction to what a byte is. For example, [[Instruction|instructions]] are simply bytes that a processor understands and based on so executes some instruction. [[String|strings]] are in fact an [[Array|array]] of bytes where each byte represents a char, or, depending of the [[Encoding]] of so, a group of bytes represent a char. Same thing for numbers. When working with [[Int|int]] in C for example, the \u0026lsquo;int\u0026rsquo; type is actually a \u0026lsquo;4 byte signed integer\u0026rsquo;. A [[Pointer|pointer]] is in 64 bit architecture, 8 bytes, and in 32 bit architecture 4 bytes, the same size as an [[usize]]. [[Objects|Objects]], supposing [[OOP]] are just pointers to the [[Heap]] that actually contain the information about the object, which is a contiguous byte array that interprets the bytes in a order. The primitives, in case, the types that are more close to bytes than any others are numbers. The reason is very simple actually: they\u0026rsquo;re simple bytes that are interpreted a way we can understand. When we print a number on the console for example, let\u0026rsquo;s say we get \u0026lsquo;5\u0026rsquo;, actually what happened is that the bits of the number are 101 and we converted it to it\u0026rsquo;s [[Ascii|ascii]] equivalent. Simple as that. In programming we have a lot of types of numbers. In languages like [[Javascript]] or [[Python]] or other high level ones we generally use a single type for everything. In rust for example we got i8, i16, i32, i64, i128 which are signed integers followed by the amount of bits each use. The same logic for \u0026lsquo;u\u0026rsquo; variants: u8, u16, u32, u64, u128. Rust follows IEEE-752 for implementing floats, or decimal values, and it contains f32 and f64, equivalents to \u0026lsquo;float\u0026rsquo; and \u0026lsquo;double\u0026rsquo; in C. Actually, the only type that Javascript supports is f64 if not using typed arrays.\n"},{"id":5,"href":"/notes/basis/pointer/","title":"Pointer","section":"Notes","content":"When working with variables, we must understand first of all what is a variable. In the RAM, we got an space of, lets say for example 8 GB, this means we have a capacity to store about 8 Billions bytes, but, what would \u0026lsquo;storing bytes\u0026rsquo; mean? In case the ram is such as a list, when we create a variable, what we are doing is getting some free position on the ram and simply using them for that variable. Let\u0026rsquo;s say the following C code:\nint main(){ char[50] v; }As a char in C is 1 byte, when this variable \u0026lsquo;v\u0026rsquo; is created, on the [[Stack|stack]] of the running program, we use get the last available position, and allocate 50 bytes, when this variable is unused, the 50 bytes are freed. So, one thing we know is that \u0026lsquo;v\u0026rsquo; actually lives at some position on the ram, more specifically, the stack of the current program. The problem is that when we try to pass variables to another place, we must do a copy. For example:\n#include \u0026lt;stdio.h\u0026gt; typedef struct { uintptr_t v1; uintptr_t v2; uintptr_t v3; } Ex; void f(Ex val){ printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;val); } int main(){ Ex val = {}; f(val); printf(\u0026#34;%p\u0026#34;, \u0026amp;val); return 0; }On running it, we can see the following:\n◄ 0s ◎ gcc ptr.c -o ptr \u0026amp;\u0026amp; ./ptr □ c/chararr ℂ v14.3.1-gcc 16:32 0x7fff3b3ca7b0 0x7fff3b3ca7d0 ◄ 0s ◎we can see that the positions are different, by subtracting the last 2 ones(0x7fff3b3ca7b0 -0x7fff3b3ca7d0), we see that the difference is 32, in case, bytes, so, we can see that the value \u0026lsquo;f\u0026rsquo; uses is not the same value defined in main, so we can see that it is being copied before being used at \u0026lsquo;f\u0026rsquo;. That is the normal pattern actually, we copy stuff to pass them between functions, but it has a downside. The most obvious is supposing you have an array with 4 kilobytes, and you call functions with it directly, each function call will copy that 4 kilobytes of memory, instead, we could simply pass the position the variable lives at and then read it from there, or modify. The way we do so is through pointers. Actually that code already uses pointers. A pointer is just a variable that holds a position on the memory, it depends on the [[Architecture|architecture]], if it\u0026rsquo;s 32 bits, we then store 32 bits for so, thus, 4 bytes, if it\u0026rsquo;s 64 bits, we then store 64 bits for so, thus, 8 bytes. Understand that a pointer is not necessarily the position of a variable, but simply a position on the memory. For sure it will have problems if we use some pointers incorrectly. We can understand arrays as an contiguous amount of data. So, lets say:\nint val[24]; int* ptr = \u0026amp;val;this will point to the first value of the array, or simply, where the array begins. We know that it\u0026rsquo;s int, so we have allocated 96 bytes. To get the Nth number on the array where $$ 0 \u0026lt; N \u0026lt; 24 $$ we can do simply: *(ptr + N). What happens is that, as the type is \u0026lsquo;int\u0026rsquo;, it\u0026rsquo;s four bytes long, so, on pointer arithmetic, ptr + 1 will walk exactly the amount of bytes required to go to the next value of the same size. Then, in actual bytes, (ptr+1) walks ptr+sizeof(typeof ptr), in this case the type of the pointer is an int, then 4 bytes are walked. So ptr+n walks \u0026rsquo;n\u0026rsquo; int\u0026rsquo;s forwards, and then the \u0026rsquo; * \u0026rsquo; operator says that it\u0026rsquo;s to dereference it. Then to get the 10th element on the array we will have: *(ptr + 10). When we want to read something from an address, we must dereference that content, thus, go to that position on the memory and read that. It\u0026rsquo;s already said before on *(ptr+N). The \u0026rsquo; * \u0026rsquo; operator is used to talk about these values. When reading or writing via a reference, in general this operator is used before, for example:\nint main(){ int val = 50; int b = \u0026amp;val; //suppose these exist; int a = *b; *b *= 4; }Both are valid. \u0026lsquo;a\u0026rsquo; copies the value on \u0026lsquo;b\u0026rsquo;, thus, reads 50, because it points to a position on the memory which contains the int \u0026lsquo;50\u0026rsquo;, and *b *= 4 on that location, we multiply the current value by 4, thus \u0026lsquo;val\u0026rsquo; will become \u0026lsquo;200\u0026rsquo; instead. One occasion where this happens often is with dynamic allocation. For example:\nint main(){ int* value = malloc(sizeof(int)*10); //an array of 10 ints }Here, a pointer must be returned because the value will live on the heap, and we must assign the data via dereference. This can be seen on [[Vector]], where the a-\u0026gt;b is equivalent to (*a).b and arr[n] is the equivalent to *(arr+n), which follows what was said about dereferences before\n"},{"id":6,"href":"/notes/concurrency/distributedlocks/","title":"Distributed Locks","section":"Notes","content":"When we talk about Distributed Locks, we are mainly talking about distributed systems, before commenting on distributed Locks, we will talk about distributed systems.\nA distributed system is a collection of independent computers (nodes) that work together and appear to the user as a single coherent system. Key characteristics:\nNetwork Communication: nodes exchanges messages (they don\u0026rsquo;t share memory directly) Concurrency: multiple machines can execute tasks simultaneously Partial failures: one machine can fail while others keep running (different from centralized systems). Consistency and coordination: since data may be spread across nodes, the system must handle synchronization, consensus, and fault tolerante(e.g., Paxos or Raft algorithms) Examples: distributes databases(Cassandra, MongoDb Cluster), distributed file systems (HDFS), coordination services (Zookeeper, Etcd), and cloud plataforms (AWS, Google Cloud) In short:\nThat’s a distributed system: many people (computers) working together as if they were one.\nNow, back to Distributed Locks. Distributed locks are sophisticated techniques used to synchronize access to shared resources in distributed environments, ensuring that only one process or node can perform a critical operation at a time, preventing conflicts, inconsistencies, and possible data corruption.\nIn distributed systems, multiple processes/nodes may attempt to access the same critical resource at the same time (e.g., updating a bank account balance, processing the same queue message, writing a file, start a schedule, job). Local locks (mutexes, semaphores) are insufficient because they only control concurrency within a single process or machine. For this we need a locking mechanism that works across multiple machines connected over the network.\nA distributed lock must provide:\nMutual Exclusion Only one client at a time can hold the lock. Deadlock prevention If the client holding the lock crashes, the lock should eventually expire(lease or TTL) Availability Even under failures, the system should continue granting locks. Consistency No two clients should ever believe they both hold the same lock. Fairness(optional) Locks can be granted in the order of requests (queue-based fairness). Commons implementations\nRedis (e.g., Redlock Algorithm) # Each client sets a key with a TTL. If the client can successfully set the key in a majority of Redis nodes, it assumes the lock. TTL ensures auto-release if the client crashes. ASCII flow:\nClient A tries to lock \u0026#34;resource-1\u0026#34; ├──\u0026gt; Redis Node 1: OK ├──\u0026gt; Redis Node 2: OK └──\u0026gt; Redis Node 3: FAIL (timeout) Majority acquired (2/3) → Client A holds the lockZookeeper # Uses ephemeral znodes: each client creates a temporary node. The client with the smallest sequence number holds the lock. If the client disconnects, its znode disappears automatically. ASCII flow:\n/locks/resource-1/ ├── lock-0001 (Client A) \u0026lt;-- LOCK OWNER ├── lock-0002 (Client B) └── lock-0003 (Client C) If the Client A crashes, Zookeeper deletes lock-0001, and Client B becomes the new owner\nEtcd # Uses leases (time-limited key ownership). Clients acquire a key with PUT key \u0026ndash;lease=10s. When the leases expires (or client crases), the key is removed Watchers notify other clients that the lock is free. General Architecture # ![[architecture-distributed-locks-system.png]]\nAll clients attempt to acquire a lock on resource X. Only one succeeds at a time. The lock expires unless it is renewed (lease). Summary\nDistributed locks are a coordination mechanism in distributed systems, typically implemented with a middleware like Redis, Zookeeper, Etcd, or Consul. They guarantee mutual exclusion, fault tolerance, and consistency when multiple processes compete for shared resources.\n"},{"id":7,"href":"/notes/datastructures/slotmap/","title":"Slot Map","section":"Notes","content":"When building a tree, if trying to make it Vector based, one of the problems it will have is that the deletion at some index I is not O(1), instead O(N), that does happen because when the data is deleted, a gap originates, but, the must vector to be contiguous and able to accessed via indices correctly, so the content to the right of I($\\forall N \\text{ where } I \u0026lt; N \u0026lt; Len$) , needs to be moved to the left, then, the cost to make so is defined as O(N). The reasons why this can be understood on [[Big O Notation]] Based on that, if I have a tree that is vector based, the time for deletion will be slow as hell, then another kind of data structure must be required, some that makes able to work with deletion and insertion at O(1). We do can work with [[LinkedList|linked lists]] but it would be O(n) to search for elements. Then the solution is a data structure that contains info about a given type T in a contiguous way, when deleting keeps that gap and reuses, and can be fast for finding. Well, that\u0026rsquo;s the case of a Slotmap. Slotmaps are just as vectors, but they simply keep the gap of where should be removed and reinsert a new element there instead of in the back or the head of a Vector or a Queue. The core idea can be understood as the following:\nstruct SlotMap\u0026lt;T\u0026gt;{ raw: Vec\u0026lt;T\u0026gt;, gaps: VecDeque\u0026lt;usize\u0026gt; } impl\u0026lt;T\u0026gt; SlotMap\u0026lt;T\u0026gt; { pub fn new() -\u0026gt; Self { Self {raw: Vec::new(), gaps:VecDeque::new()} } #[inline] pub fn push(\u0026amp;mut self, data: T) -\u0026gt; usize { if self.gaps.is_empty(){ let out = self.raw.len(); self.raw.push(data); out }else { let gap_index = self.gaps.pop_front().unwrap(); self.raw[gap_index] = data; gap_index } } pub fn remove(\u0026amp;mut self, index:usize) -\u0026gt; Result\u0026lt;(), String\u0026gt; { if(index \u0026gt; self.raw.len()) {Err(\u0026#34;Cannot remove element outside bounds\u0026#34;.to_string())} else { self.gaps.push(index); Ok(()) } } }Here we are simply storing the data and when requesting to delete at some index, we store it in a queue, when requesting to add another new, we simply check if there\u0026rsquo;s some gap, if so, we write it there\n"},{"id":8,"href":"/notes/datastructures/vector/","title":"Vector","section":"Notes","content":"When working with data, one thing that we might want to do is have a list of elements, independently of the way it\u0026rsquo;s structured, we want to have elements on a list. The first thing we can think of is using an [[Array]] but, if the content size is not known during runtime, we cannot simply store it on a array, since, they got fixed size. To manipulate something like this then, we must allocate data during runtime, thus, we think firstly on rely on top of things like [[Heap|heap]] allocation. That\u0026rsquo;s exactly the way Vectors work. Vectors are dynamic sized arrays, then, it\u0026rsquo;s correct to assume that they do allocate things on heap, more precisely, they pre-allocate an specific amount of bytes required to start working. Let\u0026rsquo;s say the following:\nfn main(){ let mut vec = Vec::with_capacity(4); vec.push(5); vec.push(40); vec.push(60); vec.push(80);\t}In rust and in others languages, the method push is used to append the data at the end of the inner array. It can be understood in C, like the following:\nint main(){ void* vec = malloc(sizeof(int)*4); int len = 0; vec[len++] = 5; vec[len++] = 40; vec[len++] = 60; vec[len++] = 80; }The thing is that when the content pushed tries to overflow, which is categorized by, trying to add an element when the array is fulfilled, we before pushing it at the end, we allocate more memory for the array so we can safely insert it.\n#include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; struct IntVec { uintptr_t len; uintptr_t cap; int* array; }; struct IntVec createWithCapacity(int capacity) { struct IntVec out; out.cap = capacity; out.len = 0; out.array = malloc(sizeof(int) * capacity); return out; } void grow(struct IntVec* vec) { vec-\u0026gt;array = realloc(vec-\u0026gt;array, vec-\u0026gt;cap * 2); vec-\u0026gt;cap *= 2; } void push(struct IntVec* vec, int data) { if(vec-\u0026gt;len == vec-\u0026gt;cap) grow(vec); vec-\u0026gt;array[vec-\u0026gt;len++] = data; } int main(){ struct IntVec vec = createWithCapacity(4); push(\u0026amp;vec, 5); push(\u0026amp;vec, 24); push(\u0026amp;vec, 29); push(\u0026amp;vec, 24); push(\u0026amp;vec, 28); for(int i = 0; i \u0026lt; vec.len; i++){ printf(\u0026#34;%d\\n\u0026#34;, vec.array[i]); } }The example code above exemplifies at a basic level a vector and how it simply reallocates memory to support more data. The implementation if a Vector in rust doubles the capacity, but it\u0026rsquo;s not necessarily all the vectors apply this rule of doubling the capacity on their implementations. For that reason, a vector insertion at any index, as well as finding a content at any index, is [[Big O Notation|O(1)]], as long as the write overwrites the content. For example vec-\u0026gt;array[5] = 10; is O(1), but the desired is to insert 10 at index 5, and what is after it, increases the index, thus, moving it to the right, the operation is now O(N) where $N = Len(arr) - idx$. This is also a way of insertion, but it supposes you shift the content, the insertion where it\u0026rsquo;s O(n) can be called \u0026lsquo;overwrite\u0026rsquo;, because you literally are writing data there. To make things easier to understand, the term \u0026lsquo;insert\u0026rsquo; will be used to talk about this kind of insertion where the content after is shifted to the right, and the one that simply writes data will be called \u0026lsquo;overwriting\u0026rsquo; To implement it we must first understand how do we do the moving of the elements. We know that on an array [5,4,3,2], if we insert 8, at the index 2, it will then become [5,4,8,3,2]. To begin with, let\u0026rsquo;s start with the function definition\nvoid insert(struct IntVec* target, int index, int value) { //here, for all values with index I, where I \u0026gt;= param(index), overwrite them at I+1 }So first let\u0026rsquo;s start with the moving. As we will move data to I+1 where I = current index, if the content vector doesn\u0026rsquo;t have size enough, it will overflow, so we MUST ensure the vector has capacity for so.\nvoid insert(struct IntVec* vec, int index, int data) { if(vec-\u0026gt;len == vec-\u0026gt;cap) grow(vec); int modifier_index = vec-\u0026gt;len; while(modifier_index \u0026gt; index) { vec-\u0026gt;array[modifier_index] = vec-\u0026gt;array[modifier_index-1]; modifier_index--; } vec-\u0026gt;array[index] = data; }And there it is, now the content is moved and the value is correctly inserted. As you probably noticed, we must start with values at the length of the vector, because length == last_pos+1, due to pointer arithmetic. Then, we move the values from N-1 to N, which is shifting them to the right. And at the index we overwrite with the content we want. The downside of using this insert method, is that for big amount of data, it will be slow, so other options must be used instead. For example, if we want some kind of [[Queue|queue]], we could use this as well, but inserting always at index 0, the problem with that is that for each insertion we would have to move things.\n"},{"id":9,"href":"/notes/excalidraw/generictree/","title":"Generic Tree","section":"Notes","content":"==⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠== You can decompress Drawing data with the command palette: \u0026lsquo;Decompress current Excalidraw file\u0026rsquo;. For more info check in plugin settings under \u0026lsquo;Saving\u0026rsquo;\nExcalidraw Data # Text Elements # 1 ^CtMEtoRV\n2 ^RoHcsysm\n3 ^ZvOgwceu\n4 ^FHXqpytF\n5 ^gT8WghOZ\n6 ^CWFRvWbd\n7 ^cEcvMJVL\n8 ^K0NVY28b\n9 ^iFlGuRaz\n10 ^pTXd8RgT\n%%\nDrawing # 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%%\n"},{"id":10,"href":"/notes/io/streams/","title":"Streams","section":"Notes","content":"Stream is a way to process data safely and efficiently. It works piece by piece, in chunks. By processing data this way, without loading all data into memory at once, it prevents server overload and improves speed and security.\nStreams are heavily used for processing binary data, whether it\u0026rsquo;s bytes or strings.\nFile Processing: Using the fs library, we can create a stream to process a file meaning to read and write it. This is perfect for handling massive log files, uploads, or downloading large files with high efficiency. Network Communication: Streams are frequently used in network communication (like HTTP, TCP, and WebSockets) to efficiently process data in chunks. In this context, they allow you to process the body of HTTP requests and responses, receive file uploads, return large amounts of data from APIs (JSON, XML), and even WebSocket communication uses data streams. Transform Streams: In this case, data is modified while it\u0026rsquo;s being processed, using a combination of readable and writable streams. Data is transformed from one format to another, typically using a pipe. For example: a program processing a huge application log could implement a Transform Stream to filter the log to only show \u0026ldquo;WARN\u0026rdquo; and \u0026ldquo;ERROR\u0026rdquo; entries. Buffer: When using streams, data doesn\u0026rsquo;t all arrive at once. It comes in chunks. Because of this, each chunk is temporarily stored in a buffer before being processed. In summary: Streams allow efficient processing of large amounts of data without overloading memory and improving application performance.\n"},{"id":11,"href":"/notes/protocols/matp/","title":"Matp","section":"Notes","content":"MATP(short for Minecraft Addons Transfer Protocol) is just a name for a theoretical protocol used to transfer data between addons on minecraft. It doesn\u0026rsquo;t exist, then, it\u0026rsquo;s not used, and I did not implement it anywhere(yet). It\u0026rsquo;s only the core idea of what a protocol actually does. This is not focused on be 100% correct, but, as said, to give a core idea of what a protocol does. In Minecraft Bedrock, until now(12/aug/25), there is no builtin way to transfer data between the so called \u0026lsquo;addons\u0026rsquo;, that are modifications inside it, the equivalent to mods on Java. So we must think a way to transfer. One thing that is does have, is to send messages to every \u0026lsquo;addon\u0026rsquo;, and each decide how to work with that message. That is called [[https://learn.microsoft.com/en-us/minecraft/creator/scriptapi/minecraft/server/scripteventcommandmessageafterevent?view=minecraft-bedrock-stable|scriptEvent]], the thing is that we need 2 things, an ID, and the content of the message. As the protocol is a bunch of rules the end users must follow to be able to interact, we can define it like the following: On the id of the scriptevent, we specify the sender ID, and the target the packet is being sent to. So far, that\u0026rsquo;s all. On the message we can simply send the bytes, but we would need some header to tell some information about the message being sent. Let\u0026rsquo;s say we want it to have confirmations about the things, so, when an addon A sends the data to the addon B, the addon B confirms it received. Then, on the header we would define if the type of message is a \u0026lsquo;Request\u0026rsquo;, \u0026lsquo;Response\u0026rsquo;, or \u0026lsquo;Reply\u0026rsquo;. When actually writing it, we will face that both the ID and the message of the scriptevent are strings, so, if we send something that contains a [[Null Character|null character]], it will fail and the content will be lost. Then we have to determine a way to send the content in a manner it will not be lost. We can use something like [[Base64|base64]], but it does add too much overhead; After using it the final content gets about 33% larger, so we don\u0026rsquo;t want it. As the target is minecraft addons, which run on JS in a [[https://bellard.org/quickjs/|quickjs]] environment, the strings are understood by default as [[Utf16]], so we can instead of sending bytes, send a packet of 2 bytes. I didn\u0026rsquo;t say, but until where i know, the total limit of chars per message is 2048, so, by sending 1 char as 1 byte, we would send only up to 2kb per message, if instead we compact 2 bytes and compact them into a single char, we could be able to send up to 4kb, so, we could use something like [[Base65536]] to actually do that before transfering the data. So our protocol is defined in theory:\nId of the message will have the sender and the target The packet will have a header containing the kind of message it\u0026rsquo;s The packet will be converted using Base65536 before being sent On receiving a packet, use base65536 to get the actual bytes In the practice, we can do some stuff to make it start taking a shape(Obs: The following codes are totally theoretical, they were not tested. The usage of rust as language is because i use it normally): Define the [[Sockets|socket]] interface Define the packet interface enum MessageHeader { Request, Response, Reply } struct MessagePacket { header:MessageHeader, content: String } struct MATPSocket { identifier: u32, target: u32, }The socket will by now contain only it\u0026rsquo;s identifier and the target. The packet contains weather it is a Request, Response or Reply and the actual content, in rust Strings are [[Utf8]], but as the target is [[Utf16]], and this is just an example code in the language I\u0026rsquo;m more comfortable with, let\u0026rsquo;s suppose the String in rust simply works as intended.\nimpl MATPSocket { pub fn new(target:u32) -\u0026gt; Self { Self {identifier: random::\u0026lt;u32\u0026gt;(), target} } ///Sends the content to minecraft to the target and returns the total amount of packets sent pub fn send_content(\u0026amp;self, content: \u0026amp;[u8]) -\u0026gt; Result\u0026lt;usize, String\u0026gt; { let mut packet_count = 0; let mut offset = 0; while offset \u0026lt; content.len() { let packet_content = \u0026amp;content[offset..(offset+4096).min(content.len())]; let packet = MessagePacket::request(packet_content); let raw: Vec\u0026lt;u16\u0026gt; = packet.to_raw(Encoding::Base65536); debug_assert!(raw.len() \u0026lt;= 2048); let id = Encoding::Base65536::encode([b\u0026#39;m\u0026#39;,b\u0026#39;a\u0026#39;,b\u0026#39;t\u0026#39;,\u0026#39;p\u0026#39;,self.identifier, self.target]); minecraft.send_script_event(id, raw); offset += 4096; } packet_count+1 } }"},{"id":12,"href":"/notes/protocols/protocol/","title":"Protocol","section":"Notes","content":"Definition # Protocols are ways to determine a default action of some. For example, when working with the internet, there are a lot of protocols that determine how the data will be sent, received, and how to act if something fails; one of them are [[TCP]]. Generally the end-user, nor the programmer write a protocol, or it\u0026rsquo;s specification, but use something that already implements this protocol. In case of TCP as mentioned, the implementation is defined by the Operating System, so the programmer writes a program that uses it from the OS itself. Some explanations about how to design some, and exactly what a protocol does, can be found at [[MATP]] where i planned all the core idea of a protocol for minecraft bedrock addons\n"},{"id":13,"href":"/notes/readme/","title":"Readme","section":"Notes","content":"My Obsidian Notes.\nReason # I\u0026rsquo;m reading a book which talks about the web, in case it\u0026rsquo;s James F. Kurose | Keith W. Ross Computer Networking A Top Down Approach. 8th Edition and i\u0026rsquo;m seeing that it will become a must to create notes, so that\u0026rsquo;s the reason.\nIntention # Note everything I know and I learn to make it accessible to others. So, this is supposed to accept contribution of others about anything they want to talk about that involves programming and the one writing it down finds interesting to share with people\nObservations # As this is open source and I accept contribution, this is language agnostic. I write things MAINLY in rust because i simply prefer so, but that doesn\u0026rsquo;t mean it\u0026rsquo;s going to be the only language on the examples of this repo. The only requirement is that the notes are written in .md to make it possible to simply copy this repo and open it with obsidian\n"},{"id":14,"href":"/notes/web/dsl/","title":"DSL","section":"Notes","content":"Continuing with the [[Nuts-and-Bolts]] about how data is shared between on web, when transferring data from a Computer or from a Cellphone to another one, there are some steps. [[Protocol|Protocols]] just make a way to both Ends to understand that data. For example, a request, in terms of web, is a content sent normally via [[TCP]] using the [[HTTP]] protocol where both Ends will understand. But the way that data is sent on the physical world is a bit different. Keeping in mind a request from the web, when made, it\u0026rsquo;s content is transformed to Radio electromagnetic waves, then the router from the [[ISP]] receives it, decode and sends to the [[ISP]] central office via cable, it depends on the way the ISP will make so, but let\u0026rsquo;s now suppose it\u0026rsquo;s with copper cables. This is called then DSL. When working with it, the router will decode the content sent from the device, maybe via [[Wifi]], then depending on the kind of data it\u0026rsquo;s, it will be sent in a determined frequency. When working with talking, because the ISP can be the provider of telephones as well, the data sent will be around 0 to 4khz, when uploading, it will be sent around 4khz to 50khz, and above that, is treated as download content, normally between 50khz to 1mhz\n"},{"id":15,"href":"/notes/web/nuts-and-bolts/","title":"Nuts and Bolts","section":"Notes","content":"Packet-switches and Communication-links # On the web, the way for sending bits from one computer to another, are made with packet-switches and communication-links, where, the communication-link is the way the data will be transferred. If the data is being sent via Wifi, then the communication-link is radio-waves. If it\u0026rsquo;s being sent via cables, the cable itself is the communication-link. When talking about the packet-switches, understanding what is a packet is crucial, but not too hard. When a content is sent, normally it\u0026rsquo;s not sent fully and once, actually, it is sent [[Streamming|streamed]], thus, each piece of the content sent, is considered a packet. What actually happens is that this little piece will get it\u0026rsquo;s header written by the packet-switch, then, the one that did so, will try to send it to the target computer, but, if the computer is not on the current [[LAN]] then it sends the data again to another packet-switch, that then does the same. Some examples of packet-switches are routers, that are defined on the Layer 3 of [[OSI|OSI model]] and Ethernet switches\nHow it\u0026rsquo;s sent # When sending the data from one computer to another, it\u0026rsquo;s important that it\u0026rsquo;s sent a way that is readable, that\u0026rsquo;s why protocols exist, they define how things should be to work. When talking about some of the [[Protocol|protocols]] used to send data, 2 are the major ones: [[TCP]] and [[IP]]. Actually, when an End system, for example some [[ClientServer|Client or Server]], wants to transfer some data, it uses a socket interface, that specifies how this end asks the Internet infrastructure to deliver the data to the correct destination. In fact, the way it\u0026rsquo;s sent is determined by a protocol, where, the other end expects that the receiver is listening with the same protocol. For example, a [[TCPClient|tcp client]] will expect that the listener will be running on [[TCP]] to understand that data correctly . In fact, there are a lot of protocols in the web. A good book that covers a lot of topics about it is: Computer Networking a Top Down Approach.\n"}]