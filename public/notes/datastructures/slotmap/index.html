<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="When building a tree, if trying to make it Vector based, one of the problems it will have is that the deletion at some index I is not O(1), instead O(N), that does happen because when the data is deleted, a gap originates, but, the must vector to be contiguous and able to accessed via indices correctly, so the content to the right of I($\forall  N \text{ where } I &lt; N &lt; Len$) ,  needs to be moved to the left, then, the cost to make so is defined as O(N). The reasons why this can be understood on [[Big O Notation]]
Based on that, if I have a tree that is vector based, the time for deletion will be slow as hell, then another kind of data structure must be required, some that makes able to work with deletion and insertion at O(1). We do can work with [[LinkedList|linked lists]] but it would be O(n) to search for elements. Then the solution is a data structure that contains info about a given type T in a contiguous way, when deleting keeps that gap and reuses, and can be fast for finding. Well, that&rsquo;s the case of a Slotmap.
Slotmaps are just as vectors, but they simply keep the gap of where should be removed and reinsert a new element there instead of in the back or the head of a Vector or a Queue. The core idea can be understood as the following:">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="http://localhost:1313/notes/datastructures/slotmap/">
  <meta property="og:site_name" content="My New Hugo Site">
  <meta property="og:title" content="My New Hugo Site">
  <meta property="og:description" content="When building a tree, if trying to make it Vector based, one of the problems it will have is that the deletion at some index I is not O(1), instead O(N), that does happen because when the data is deleted, a gap originates, but, the must vector to be contiguous and able to accessed via indices correctly, so the content to the right of I($\forall N \text{ where } I &lt; N &lt; Len$) , needs to be moved to the left, then, the cost to make so is defined as O(N). The reasons why this can be understood on [[Big O Notation]] Based on that, if I have a tree that is vector based, the time for deletion will be slow as hell, then another kind of data structure must be required, some that makes able to work with deletion and insertion at O(1). We do can work with [[LinkedList|linked lists]] but it would be O(n) to search for elements. Then the solution is a data structure that contains info about a given type T in a contiguous way, when deleting keeps that gap and reuses, and can be fast for finding. Well, thatâ€™s the case of a Slotmap. Slotmaps are just as vectors, but they simply keep the gap of where should be removed and reinsert a new element there instead of in the back or the head of a Vector or a Queue. The core idea can be understood as the following:">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="notes">
<title>Slot Map | My New Hugo Site</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="http://localhost:1313/notes/datastructures/slotmap/">
<link rel="stylesheet" href="/book.min.1a2cf7ebc00040820952c4e2341e71d7d5b60d173ee3438ff388e77e880de9df.css" integrity="sha256-Giz368AAQIIJUsTiNB5x19W2DRc&#43;40OP84jnfogN6d8=" crossorigin="anonymous">


  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.67e33560f484200bd7322deb340ca99efcd4b1b1930fd430a7c5b86139554f3d.js" integrity="sha256-Z&#43;M1YPSEIAvXMi3rNAypnvzUsbGTD9Qwp8W4YTlVTz0=" crossorigin="anonymous"></script>

  
</head>
<body dir="ltr" class="book-kind-page book-type-notes book-layout-">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    
<aside class="book-menu">
  <div class="book-menu-content">
    
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>My New Hugo Site</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>
























</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>



  </div>
</aside>
 

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/icons/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>Slot Map</h3>

  <label for="toc-control">
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents"></nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><p>When building a tree, if trying to make it Vector based, one of the problems it will have is that the deletion at some index I is not O(1), instead O(N), that does happen because when the data is deleted, a gap originates, but, the must vector to be contiguous and able to accessed via indices correctly, so the content to the right of I($\forall  N \text{ where } I &lt; N &lt; Len$) ,  needs to be moved to the left, then, the cost to make so is defined as O(N). The reasons why this can be understood on [[Big O Notation]]
Based on that, if I have a tree that is vector based, the time for deletion will be slow as hell, then another kind of data structure must be required, some that makes able to work with deletion and insertion at O(1). We do can work with [[LinkedList|linked lists]] but it would be O(n) to search for elements. Then the solution is a data structure that contains info about a given type T in a contiguous way, when deleting keeps that gap and reuses, and can be fast for finding. Well, that&rsquo;s the case of a Slotmap.
Slotmaps are just as vectors, but they simply keep the gap of where should be removed and reinsert a new element there instead of in the back or the head of a Vector or a Queue. The core idea can be understood as the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">SlotMap</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>{
</span></span><span style="display:flex;"><span>	raw: Vec<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>	gaps: <span style="color:#a6e22e">VecDeque</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> SlotMap<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>() -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>		Self {raw: Vec::new(), gaps:<span style="color:#a6e22e">VecDeque</span>::new()}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#[inline]</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">push</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, data: <span style="color:#a6e22e">T</span>) -&gt; <span style="color:#66d9ef">usize</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> self.gaps.is_empty(){
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">let</span> out <span style="color:#f92672">=</span> self.raw.len();
</span></span><span style="display:flex;"><span>			self.raw.push(data);
</span></span><span style="display:flex;"><span>			out
</span></span><span style="display:flex;"><span>		}<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">let</span> gap_index <span style="color:#f92672">=</span> self.gaps.pop_front().unwrap();
</span></span><span style="display:flex;"><span>			self.raw[gap_index] <span style="color:#f92672">=</span> data;
</span></span><span style="display:flex;"><span>			gap_index
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">remove</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, index:<span style="color:#66d9ef">usize</span>) -&gt; Result<span style="color:#f92672">&lt;</span>(), String<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span>(index <span style="color:#f92672">&gt;</span> self.raw.len()) {Err(<span style="color:#e6db74">&#34;Cannot remove element outside bounds&#34;</span>.to_string())}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			self.gaps.push(index);
</span></span><span style="display:flex;"><span>			Ok(())
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Here we are simply storing the data and when requesting to delete at some index, we store it in a queue, when requesting to add another new, we simply check if there&rsquo;s some gap, if so, we write it there</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">

<div>

</div>

<div>

</div>

</div>









  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
  
  <div class="book-comments">

</div>
  
 
        
        

 
      </footer>

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    

 
  </main>

  
</body>
</html>


















