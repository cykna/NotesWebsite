<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="MATP(short for Minecraft Addons Transfer Protocol) is just a name for a theoretical protocol used to transfer data between addons on minecraft.
It doesn&rsquo;t exist, then, it&rsquo;s not used, and I did not implement it anywhere(yet). It&rsquo;s only the core idea of what a protocol actually does. This is not focused on be 100% correct, but, as said, to give a core idea of what a protocol does.
In Minecraft Bedrock, until now(12/aug/25), there is no builtin way to transfer data between the so called &lsquo;addons&rsquo;, that are modifications inside it, the equivalent to mods on Java. So we must think a way to transfer. One thing that is does have, is to send messages to every &lsquo;addon&rsquo;, and each decide how to work with that message. That is called [[https://learn.microsoft.com/en-us/minecraft/creator/scriptapi/minecraft/server/scripteventcommandmessageafterevent?view=minecraft-bedrock-stable|scriptEvent]], the thing is that we need 2 things, an ID, and the content  of the message.
As the protocol is a bunch of rules the end users must follow to be able to interact, we can define it like the following:
On the id of the scriptevent, we specify the sender ID, and the target the packet is being sent to. So far, that&rsquo;s all.
On the message we can simply send the bytes, but we would need some header to tell some information about the message being sent. Let&rsquo;s say we want it to have confirmations about the things, so, when an addon A sends the data to the addon B, the addon B confirms it received. Then, on the header we would define if the type of message is a &lsquo;Request&rsquo;, &lsquo;Response&rsquo;, or &lsquo;Reply&rsquo;.
When actually writing it, we will face that both the ID and the message of the scriptevent are strings, so, if we send something that contains a [[Null Character|null character]], it will fail and the content will be lost. Then we have to determine a way to send the content in a manner it will not be lost. We can use something like [[Base64|base64]], but it does add too much overhead; After using it the final content gets about 33% larger, so we don&rsquo;t want it. As the target is minecraft addons, which run on JS in a [[https://bellard.org/quickjs/|quickjs]] environment, the strings are understood by default as [[Utf16]], so we can instead of sending bytes, send a packet of 2 bytes. I didn&rsquo;t say, but until where i know, the total limit of chars per message is 2048, so, by sending 1 char as 1 byte, we would send only up to 2kb per message, if instead we compact 2 bytes and compact them into a single char, we could be able to send up to 4kb, so, we could use something like [[Base65536]] to actually do that before transfering the data.
So our protocol is defined in theory:">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="https://example.org/notes/protocols/matp/">
  <meta property="og:site_name" content="My New Hugo Site">
  <meta property="og:title" content="My New Hugo Site">
  <meta property="og:description" content="MATP(short for Minecraft Addons Transfer Protocol) is just a name for a theoretical protocol used to transfer data between addons on minecraft. It doesn’t exist, then, it’s not used, and I did not implement it anywhere(yet). It’s only the core idea of what a protocol actually does. This is not focused on be 100% correct, but, as said, to give a core idea of what a protocol does. In Minecraft Bedrock, until now(12/aug/25), there is no builtin way to transfer data between the so called ‘addons’, that are modifications inside it, the equivalent to mods on Java. So we must think a way to transfer. One thing that is does have, is to send messages to every ‘addon’, and each decide how to work with that message. That is called [[https://learn.microsoft.com/en-us/minecraft/creator/scriptapi/minecraft/server/scripteventcommandmessageafterevent?view=minecraft-bedrock-stable|scriptEvent]], the thing is that we need 2 things, an ID, and the content of the message. As the protocol is a bunch of rules the end users must follow to be able to interact, we can define it like the following: On the id of the scriptevent, we specify the sender ID, and the target the packet is being sent to. So far, that’s all. On the message we can simply send the bytes, but we would need some header to tell some information about the message being sent. Let’s say we want it to have confirmations about the things, so, when an addon A sends the data to the addon B, the addon B confirms it received. Then, on the header we would define if the type of message is a ‘Request’, ‘Response’, or ‘Reply’. When actually writing it, we will face that both the ID and the message of the scriptevent are strings, so, if we send something that contains a [[Null Character|null character]], it will fail and the content will be lost. Then we have to determine a way to send the content in a manner it will not be lost. We can use something like [[Base64|base64]], but it does add too much overhead; After using it the final content gets about 33% larger, so we don’t want it. As the target is minecraft addons, which run on JS in a [[https://bellard.org/quickjs/|quickjs]] environment, the strings are understood by default as [[Utf16]], so we can instead of sending bytes, send a packet of 2 bytes. I didn’t say, but until where i know, the total limit of chars per message is 2048, so, by sending 1 char as 1 byte, we would send only up to 2kb per message, if instead we compact 2 bytes and compact them into a single char, we could be able to send up to 4kb, so, we could use something like [[Base65536]] to actually do that before transfering the data. So our protocol is defined in theory:">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="notes">
<title>Matp | My New Hugo Site</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="https://example.org/notes/protocols/matp/">
<link rel="stylesheet" href="/book.min.1a2cf7ebc00040820952c4e2341e71d7d5b60d173ee3438ff388e77e880de9df.css" integrity="sha256-Giz368AAQIIJUsTiNB5x19W2DRc&#43;40OP84jnfogN6d8=" crossorigin="anonymous">


  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.67e33560f484200bd7322deb340ca99efcd4b1b1930fd430a7c5b86139554f3d.js" integrity="sha256-Z&#43;M1YPSEIAvXMi3rNAypnvzUsbGTD9Qwp8W4YTlVTz0=" crossorigin="anonymous"></script>

  
</head>
<body dir="ltr" class="book-kind-page book-type-notes book-layout-">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    
<aside class="book-menu">
  <div class="book-menu-content">
    
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>My New Hugo Site</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>
























</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>



  </div>
</aside>
 

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/icons/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>Matp</h3>

  <label for="toc-control">
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents"></nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><p>MATP(short for Minecraft Addons Transfer Protocol) is just a name for a theoretical protocol used to transfer data between addons on minecraft.
It doesn&rsquo;t exist, then, it&rsquo;s not used, and I did not implement it anywhere(yet). It&rsquo;s only the core idea of what a protocol actually does. This is not focused on be 100% correct, but, as said, to give a core idea of what a protocol does.
In Minecraft Bedrock, until now(12/aug/25), there is no builtin way to transfer data between the so called &lsquo;addons&rsquo;, that are modifications inside it, the equivalent to mods on Java. So we must think a way to transfer. One thing that is does have, is to send messages to every &lsquo;addon&rsquo;, and each decide how to work with that message. That is called [[https://learn.microsoft.com/en-us/minecraft/creator/scriptapi/minecraft/server/scripteventcommandmessageafterevent?view=minecraft-bedrock-stable|scriptEvent]], the thing is that we need 2 things, an ID, and the content  of the message.
As the protocol is a bunch of rules the end users must follow to be able to interact, we can define it like the following:
On the id of the scriptevent, we specify the sender ID, and the target the packet is being sent to. So far, that&rsquo;s all.
On the message we can simply send the bytes, but we would need some header to tell some information about the message being sent. Let&rsquo;s say we want it to have confirmations about the things, so, when an addon A sends the data to the addon B, the addon B confirms it received. Then, on the header we would define if the type of message is a &lsquo;Request&rsquo;, &lsquo;Response&rsquo;, or &lsquo;Reply&rsquo;.
When actually writing it, we will face that both the ID and the message of the scriptevent are strings, so, if we send something that contains a [[Null Character|null character]], it will fail and the content will be lost. Then we have to determine a way to send the content in a manner it will not be lost. We can use something like [[Base64|base64]], but it does add too much overhead; After using it the final content gets about 33% larger, so we don&rsquo;t want it. As the target is minecraft addons, which run on JS in a [[https://bellard.org/quickjs/|quickjs]] environment, the strings are understood by default as [[Utf16]], so we can instead of sending bytes, send a packet of 2 bytes. I didn&rsquo;t say, but until where i know, the total limit of chars per message is 2048, so, by sending 1 char as 1 byte, we would send only up to 2kb per message, if instead we compact 2 bytes and compact them into a single char, we could be able to send up to 4kb, so, we could use something like [[Base65536]] to actually do that before transfering the data.
So our protocol is defined in theory:</p>
<ul>
<li>Id of the message will have the sender and the target</li>
<li>The packet will have a header containing the kind of message it&rsquo;s</li>
<li>The packet will be converted using Base65536 before being sent</li>
<li>On receiving a packet, use base65536 to get the actual bytes
In the practice, we can do some stuff to make it start taking a shape(Obs: The following codes are totally theoretical, they were not tested. The usage of rust as language is because i use it normally):
Define the [[Sockets|socket]] interface
Define the packet interface</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">MessageHeader</span> {
</span></span><span style="display:flex;"><span>	Request,
</span></span><span style="display:flex;"><span>	Response,
</span></span><span style="display:flex;"><span>	Reply
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MessagePacket</span> {
</span></span><span style="display:flex;"><span>	header:<span style="color:#a6e22e">MessageHeader</span>,
</span></span><span style="display:flex;"><span>	content: String
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MATPSocket</span> {
</span></span><span style="display:flex;"><span>	identifier: <span style="color:#66d9ef">u32</span>,
</span></span><span style="display:flex;"><span>	target: <span style="color:#66d9ef">u32</span>,
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>The socket will by now contain only it&rsquo;s identifier and the target. The packet contains weather it is a Request,  Response or Reply and the actual content, in rust Strings are [[Utf8]], but as the target is [[Utf16]], and this is just an example code in the language I&rsquo;m more comfortable with, let&rsquo;s suppose the String in rust simply works as intended.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> MATPSocket {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(target:<span style="color:#66d9ef">u32</span>) -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>		Self {identifier: <span style="color:#a6e22e">random</span>::<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u32</span><span style="color:#f92672">&gt;</span>(), target}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">///Sends the content to minecraft to the target and returns the total amount of packets sent
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>	<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">send_content</span>(<span style="color:#f92672">&amp;</span>self, content: <span style="color:#66d9ef">&amp;</span>[<span style="color:#66d9ef">u8</span>]) -&gt; Result<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span>, String<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> packet_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> offset <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span> offset <span style="color:#f92672">&lt;</span> content.len() {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">let</span> packet_content <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>content[offset<span style="color:#f92672">..</span>(offset<span style="color:#f92672">+</span><span style="color:#ae81ff">4096</span>).min(content.len())];
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">let</span> packet <span style="color:#f92672">=</span> MessagePacket::request(packet_content);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">let</span> raw: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u16</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> packet.to_raw(Encoding::Base65536);
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">debug_assert!</span>(raw.len() <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">2048</span>);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">let</span> id <span style="color:#f92672">=</span> Encoding::Base65536::encode([<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;m&#39;</span>,<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;a&#39;</span>,<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;t&#39;</span>,<span style="color:#e6db74">&#39;p&#39;</span>,self.identifier, self.target]);
</span></span><span style="display:flex;"><span>			minecraft.send_script_event(id, raw);
</span></span><span style="display:flex;"><span>			offset <span style="color:#f92672">+=</span> <span style="color:#ae81ff">4096</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		packet_count<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">

<div>

</div>

<div>

</div>

</div>









  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
  
  <div class="book-comments">

</div>
  
 
        
        

 
      </footer>

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    

 
  </main>

  
</body>
</html>


















