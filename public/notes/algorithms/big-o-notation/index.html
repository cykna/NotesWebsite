<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Big O Notation is the way people use to talk about the growing of some algorithm. This can be used on performance, memory usage and others, even though talking about these we require more than simply Big O. When working with Big O, we will work actually with a rule that can be applied to a code to measure it, but it doesn&rsquo;t mean that code will always be run slowly or fast. Actually, an optimized code can run slowly if the machine running it isn&rsquo;t fast enough, while, a non-optimized code can run it with not so much problems if the machine running it is fast enough for so.
In reality what big o will do estimate how much a code will need to finish based on an input I, or grow in terms of memory. Here it&rsquo;s being talked mainly about the amount of instructions to finish some algorithm.
For measuring so we use the &lsquo;O&rsquo; notation. To things don&rsquo;t keep too theoretical, let&rsquo;s suppose the following code:">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="http://localhost:1313/notes/algorithms/big-o-notation/">
  <meta property="og:site_name" content="My New Hugo Site">
  <meta property="og:title" content="My New Hugo Site">
  <meta property="og:description" content="Big O Notation is the way people use to talk about the growing of some algorithm. This can be used on performance, memory usage and others, even though talking about these we require more than simply Big O. When working with Big O, we will work actually with a rule that can be applied to a code to measure it, but it doesn’t mean that code will always be run slowly or fast. Actually, an optimized code can run slowly if the machine running it isn’t fast enough, while, a non-optimized code can run it with not so much problems if the machine running it is fast enough for so. In reality what big o will do estimate how much a code will need to finish based on an input I, or grow in terms of memory. Here it’s being talked mainly about the amount of instructions to finish some algorithm. For measuring so we use the ‘O’ notation. To things don’t keep too theoretical, let’s suppose the following code:">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="notes">
<title>Big O Notation | My New Hugo Site</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="http://localhost:1313/notes/algorithms/big-o-notation/">
<link rel="stylesheet" href="/book.min.1a2cf7ebc00040820952c4e2341e71d7d5b60d173ee3438ff388e77e880de9df.css" integrity="sha256-Giz368AAQIIJUsTiNB5x19W2DRc&#43;40OP84jnfogN6d8=" crossorigin="anonymous">


  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.67e33560f484200bd7322deb340ca99efcd4b1b1930fd430a7c5b86139554f3d.js" integrity="sha256-Z&#43;M1YPSEIAvXMi3rNAypnvzUsbGTD9Qwp8W4YTlVTz0=" crossorigin="anonymous"></script>

  
</head>
<body dir="ltr" class="book-kind-page book-type-notes book-layout-">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    
<aside class="book-menu">
  <div class="book-menu-content">
    
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>My New Hugo Site</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>
























</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>



  </div>
</aside>
 

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/icons/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>Big O Notation</h3>

  <label for="toc-control">
    
    <img src="/icons/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#on">O(N²)</a></li>
    <li><a href="#not-necessarily-good">Not Necessarily Good</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><p>Big O Notation is the way people use to talk about the growing of some algorithm. This can be used on performance, memory usage and others, even though talking about these we require more than simply Big O. When working with Big O, we will work actually with a rule that can be applied to a code to measure it, but it doesn&rsquo;t mean that code will always be run slowly or fast. Actually, an optimized code can run slowly if the machine running it isn&rsquo;t fast enough, while, a non-optimized code can run it with not so much problems if the machine running it is fast enough for so.
In reality what big o will do estimate how much a code will need to finish based on an input I, or grow in terms of memory. Here it&rsquo;s being talked mainly about the amount of instructions to finish some algorithm.
For measuring so we use the &lsquo;O&rsquo; notation. To things don&rsquo;t keep too theoretical, let&rsquo;s suppose the following code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#e6db74">///Creates a new Vector with each value following the rule: I * Position, where L is the value provided on the `input` vector and Position it&#39;s index on it
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">double_vector</span>(vec: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">f32</span><span style="color:#f92672">&gt;</span>) -&gt; Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">f32</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	vec.iter().enumerate().map(<span style="color:#f92672">|</span>(index,value)<span style="color:#f92672">|</span> value <span style="color:#f92672">*</span> index <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f32</span>)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Let&rsquo;s say we executed <code>double_vector(vec![5.0f32, 10.0, 20.0, 15.0, 12.0, 17.0])</code>. What&rsquo;s going to happen is that the code will have to iterate over this [[Vector|vector]] and produce a new one based on it. On this example, then, the function inside the map will be executed 6 times, but, lets suppose we create a new vector with 1000 elements. Something like <code>double_vector(random_vector(1000))</code> will then execute 1000 times.
Now we can find a pattern! That is: the code will run the L times to finish, where L is the length of elements of the input vector, thus, we can say that the code is O(L) because, based on L, L operations happen.
Let&rsquo;s suppose now the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">arbitrary_calc</span>(vec: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u32</span><span style="color:#f92672">&gt;</span>) -&gt; Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u32</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> out <span style="color:#f92672">=</span> Vec::new();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> val <span style="color:#66d9ef">in</span> vec {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> n <span style="color:#f92672">=</span> val <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>		n <span style="color:#f92672">+=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>		out.push(n);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Here we execute an allocation, a multiplication, a sum, and a pushing, then we are executing about O(n * 4) instructions, where <code>n</code>is the amount of elements in <code>vec</code>. The thing is that on getting bigger and bigger, what will take more effect on the amount of instructions required to finish is <code>n</code>, then, we can say the function is still O(n)</p>
<h2 id="on">O(N²)
  <a class="anchor" href="#on">#</a></h2>
<p>When something is understood as O(n²), that means that the way a given function <code>f</code> increases based on the given input is squared, for example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">has_pair_with_sum</span>(nums: <span style="color:#66d9ef">&amp;</span>[<span style="color:#66d9ef">i32</span>], target: <span style="color:#66d9ef">i32</span>) -&gt; <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>nums.len() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> j <span style="color:#66d9ef">in</span> (i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)<span style="color:#f92672">..</span>nums.len() {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> nums[i] <span style="color:#f92672">+</span> nums[j] <span style="color:#f92672">==</span> target {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Supposing we called this function as <code>has_pair_with_sum(&amp;[10, 20, 4, 13, 7], 20)</code>, and supposing the worst case where we got to iterate over all the slice, we will have that:</p>
<ul>
<li>The code starts running from <code>0..5</code> given by the <code>0..nums.len()</code>, then, we will run from <code>1..5</code> and check, so we will have 4 instructions made.</li>
<li>On the next we will do <code>1..5</code> and <code>2..5</code>, which will be more 3</li>
<li>On the next we will do <code>2..5</code> and <code>3..5</code> which will be more 2</li>
<li>On the next we will do <code>3..5</code> and <code>4..5</code> which will be more 1</li>
<li>On the next, no more is made
So in the total we will have about 10 instructions made. Well, the pattern understood is that based on a given [[Slice|slice]] with N elements, we will have about</li>
</ul>
<p>$$\sum_{k=1}^N k$$
So, on a input of 6 elements, we will have 15 instructions, on 7 instructions, 21, later 28, and so on. The given summary formula can be then rewrote as the following:
$$S = 1 + 2 + 3 .. + N$$
which, when we invert so, it can be rewritten as the following:
$$S = N + (N-1) + (N-2) + (N-3) .. + 2 + 1$$
where S = the total amount of instructions needed to execute on the worst case. Actually on summing both sides, we will have the following formula
$$S = 1 + 2 + 3 .. + N$$
$$S = N + (N-1)+(N-2) .. + 1$$
$$ S + S = (N+1) + ((N-1)+2) + ((N-2) + 3) .. + ((N + 1)$$
Which can be simplified to:
$$2S = (N+1)+(N+1)+(N+1)+(N+1)..+(N+1)$$
Where the amount of the [[BinaryExpression|right hand side]] of sums of (N+1) is N, so, we can rewrite it another way like:
$$2S = N(N+1)$$
$$S = N(N+1)/2$$ $$S = (N²+N)/2$$
which contains a N². So, as the amount of inputs increase, this is the order of how much the function will increase. Actually it&rsquo;s <code>O(N(N+1)/2)</code>, but as N² is the thing that will start to take more effect on the total amount of instructions needed to finish, we can ignore the others and then write it as simple as <code>O(N²)</code>
The same logic follows Big O all around when we talk about <code>O(log n)</code> <code>O(n log n)</code> <code>O(n!)</code>and others.</p>
<h2 id="not-necessarily-good">Not Necessarily Good
  <a class="anchor" href="#not-necessarily-good">#</a></h2>
<p>When using [[LinkedList|linked lists]] for example, we find that it&rsquo;s O(1) for insertion, but not necessarily it&rsquo;s a good thing. For insertion on the middle of the list, if not knowing the correct node, it&rsquo;s O(n), because we might traverse all the list to then find the one we want to insert something at. Another problem is that as linked lists are not a contiguous memory block, which then makes it not [[CpuCaching|cache friendly]], which can degrade performance depending on the amount of elements on the list. Depending on the amount of the data, as linked lists use pointers to define the next node, this can cause overhead, which for example, arrays do not have.
That doesn&rsquo;t mean that Big O is &lsquo;wrong&rsquo; but we need to actually consider other things than only it when talking about memory usage and performance. It can, and is used as a parameter but lacks of completeness to determine is some is actually good or not. When talking about performance, in general, it&rsquo;s just going to say how many instructions are required to some algorithm finalize</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">

<div>

</div>

<div>

</div>

</div>









  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
  
  <div class="book-comments">

</div>
  
 
        
        

 
      </footer>

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    

<aside class="book-toc">
  <div class="book-toc-content">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#on">O(N²)</a></li>
    <li><a href="#not-necessarily-good">Not Necessarily Good</a></li>
  </ul>
</nav>



  </div>
</aside>

 
  </main>

  
</body>
</html>


















