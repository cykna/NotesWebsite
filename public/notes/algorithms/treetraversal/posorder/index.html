<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="PosOrder is practically the opposite of [[PreOrder]] when working with trees. [[PreOrder]] defines that something will happen with the children first, then, it will happen with the parent. PosOrder is the opposite, it happens with the parent first, and then the children. One example is an [[UI]] that is defined as a Tree, which isn&rsquo;t unusual. When rendering so, we cannot render the children before the parents, which would be categorized as PreOrder, instead, we MUST, draw first the parents and going deeper on the children, then, the children will appear on top of the parents. This can be reached by the following code:">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="https://example.org/notes/algorithms/treetraversal/posorder/">
  <meta property="og:site_name" content="My New Hugo Site">
  <meta property="og:title" content="My New Hugo Site">
  <meta property="og:description" content="PosOrder is practically the opposite of [[PreOrder]] when working with trees. [[PreOrder]] defines that something will happen with the children first, then, it will happen with the parent. PosOrder is the opposite, it happens with the parent first, and then the children. One example is an [[UI]] that is defined as a Tree, which isnâ€™t unusual. When rendering so, we cannot render the children before the parents, which would be categorized as PreOrder, instead, we MUST, draw first the parents and going deeper on the children, then, the children will appear on top of the parents. This can be reached by the following code:">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="notes">
<title>Pos Order | My New Hugo Site</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="https://example.org/notes/algorithms/treetraversal/posorder/">
<link rel="stylesheet" href="/book.min.1a2cf7ebc00040820952c4e2341e71d7d5b60d173ee3438ff388e77e880de9df.css" integrity="sha256-Giz368AAQIIJUsTiNB5x19W2DRc&#43;40OP84jnfogN6d8=" crossorigin="anonymous">


  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.67e33560f484200bd7322deb340ca99efcd4b1b1930fd430a7c5b86139554f3d.js" integrity="sha256-Z&#43;M1YPSEIAvXMi3rNAypnvzUsbGTD9Qwp8W4YTlVTz0=" crossorigin="anonymous"></script>

  
</head>
<body dir="ltr" class="book-kind-page book-type-notes book-layout-">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    
<aside class="book-menu">
  <div class="book-menu-content">
    
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>My New Hugo Site</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>
























</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>



  </div>
</aside>
 

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/icons/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>Pos Order</h3>

  <label for="toc-control">
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents"></nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><p>PosOrder is practically the opposite of [[PreOrder]] when working with trees. [[PreOrder]] defines that something will happen with the children first, then, it will happen with the parent. PosOrder is the opposite, it happens with the parent first, and then the children. One example is an [[UI]] that is defined as a Tree, which isn&rsquo;t unusual. When rendering so, we cannot render the children before the parents, which would be categorized as PreOrder, instead, we MUST, draw first the parents and going deeper on the children, then, the children will appear on top of the parents. This can be reached by the following code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#e6db74">///Renders the given `element` using the `painter` and it&#39;s children. `set` is used to get track of which
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">///elements were already drawn, and `key` is the key of the `element` is going to be drawed
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">render_element</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;</span>self,
</span></span><span style="display:flex;"><span>        painter: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> P,
</span></span><span style="display:flex;"><span>        element: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">CandyNode</span><span style="color:#f92672">&lt;</span>P<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>        set: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> HashSet<span style="color:#f92672">&lt;</span>CandyKey<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>        key: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">CandyKey</span>,
</span></span><span style="display:flex;"><span>    ) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> set.contains(key) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        set.insert(<span style="color:#f92672">*</span>key);
</span></span><span style="display:flex;"><span>        element.render(painter);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> child_key <span style="color:#66d9ef">in</span> element.children() {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(child) <span style="color:#f92672">=</span> self.elements.get(<span style="color:#f92672">*</span>child_key) {
</span></span><span style="display:flex;"><span>                self.render_element(painter, child, set, child_key);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">///Render all the tree using the given `painter`
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">render</span>(<span style="color:#f92672">&amp;</span>self, painter: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> P) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> set <span style="color:#f92672">=</span> HashSet::new();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (key, el) <span style="color:#66d9ef">in</span> self.elements.iter() {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> set.contains(<span style="color:#f92672">&amp;</span>key) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            self.render_element(painter, el, <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> set, <span style="color:#f92672">&amp;</span>key);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }<span style="color:#960050;background-color:#1e0010">```</span>
</span></span><span style="display:flex;"><span>Note that all the logic is made first on the current <span style="color:#960050;background-color:#1e0010">`</span>element<span style="color:#960050;background-color:#1e0010">`</span> and then on the element <span style="color:#960050;background-color:#1e0010">`</span>children<span style="color:#960050;background-color:#1e0010">`</span> which calls the same function [[Recursion<span style="color:#f92672">|</span>recursively]]</span></span></code></pre></div></article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">

<div>

</div>

<div>

</div>

</div>









  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
  
  <div class="book-comments">

</div>
  
 
        
        

 
      </footer>

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    

 
  </main>

  
</body>
</html>


















